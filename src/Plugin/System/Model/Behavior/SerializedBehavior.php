<?php
/**
 * Licensed under The GPL-3.0 License
 * For full copyright and license information, please see the LICENSE.txt
 * Redistributions of files must retain the above copyright notice.
 *
 * @since	 1.0.0
 * @author	 Christopher Castro <chris@quickapps.es>
 * @link	 http://www.quickappscms.org
 * @license	 http://opensource.org/licenses/gpl-3.0.html GPL-3.0 License
 */
namespace System\Model\Behavior;

use Cake\Event\Event;
use Cake\ORM\Behavior;
use Cake\ORM\Entity;
use Cake\ORM\Table;

/**
 * Serialized Behavior.
 *
 * Allow entities to store arrays of information under a single table column.
 *
 * Usage:
 *
 *     // single field
 *     TableRegistry('TableName')->addBehavior('System.Serialized', 'column_1');
 *
 *     // multiple fields
 *     TableRegistry('TableName')->addBehavior(
 *        'System.Serialized',
 *        [
 *            'fields' => [
 *                'column_1',
 *                'column_2',
 *                ...
 *            ]
 *        ]
 *     );
 */
class SerializedBehavior extends Behavior {

/**
 * Default configuration.
 *
 * These are merged with user-provided configuration when the behavior is used.
 *
 * @var array
 */
	protected $_defaultConfig = [
		'fields' => [],
	];

/**
 * Table which this behavior is attached to.
 *
 * @var \Cake\ORM\Table
 */
	protected $_table;

/**
 * Class constructor.
 *
 * @param \Cake\ORM\Table $table The table this behavior is attached to
 * @param array|string $config Configuration array for this behavior. Or string
 * for serialize a single field.
 * @return void
 */
	public function __construct(Table $table, $config = []) {
		$this->_table = $table;

		if (!is_array($config)) {
			$config = ['fields' => $config];
		}

		parent::__construct($table, $config);
	}

/**
 * Unserialize all the fields for each entity.
 *
 * @param \Cake\Event\Event $event The `beforeFind` event that was fired
 * @param Query $query The original query to modify
 * @return void
 */
	public function beforeFind(Event $event, $query) {
		$config = $this->config();
		$tableFields = $this->_table->schema()->columns();

		$query->formatResults(function($results) use ($tableFields, $config) {
			return $results->map(function($row) use ($tableFields, $config) {
				foreach ((array)$config['fields'] as $field) {
					// ONLY REAL COLUMNS (from table schema) are serializable.
					// We skip virtual fields, or those generated by other behaviors
					// such as `FieldableBehavior`
					if (in_array($field, $tableFields) && $row->has($field)) {
						$value = $row->get($field);
						$data = $this->__unserialize($value);
						$row->set($field, $data, ['guard' => false]);
					}
				}

				return $row;
			});
		});
	}

/**
 * Before save callback.
 *
 * @param \Cake\Event\Event $event The `beforeSave` event that was fired
 * @param \Cake\ORM\Entity $entity The table entity to modify
 * @return void
 */
	public function beforeSave(Event $event, Entity $entity) {
		$config = $this->config();

		foreach ((array)$config['fields'] as $field) {
			if ($entity->has($field)) {
				$value = $entity->get($field);

				$entity->accessible($field, true);
				$entity->set($field, $this->__serialize($value));
			}
		}
	}

/**
 * After save callback.
 *
 * @param \Cake\Event\Event $event The `beforeSave` event that was fired
 * @param \Cake\ORM\Entity $entity The table entity to modify
 * @return void
 */
	public function afterSave(Event $event, Entity $entity) {
		$config = $this->config();

		foreach ((array)$config['fields'] as $field) {
			if ($entity->has($field)) {
				$value = $entity->get($field);
				$entity->set($field, $this->__unserialize($value));
			}
		}
	}

/**
 * Unserializes the given string.
 *
 * @param string $serialized Serialized string to unserialize
 * @return array The unserialized string
 */
	private function __unserialize($serialized) {
		//@codingStandardsIgnoreStart
		$value = @unserialize($serialized);
		//@codingStandardsIgnoreEnd
		$value = is_array($value) && !empty($value) ? $value : [];

		return new \Cake\ORM\Entity($value);
	}

/**
 * Serializes the given array.
 *
 * @param array $data Array to serialize
 * @return string The serialized array
 */
	private function __serialize($data) {
		if (!is_array($data)) {
			$data = [];
		}
		//@codingStandardsIgnoreStart
		$value = @serialize($data);
		//@codingStandardsIgnoreEnd

		return (string)$value;
	}

}
